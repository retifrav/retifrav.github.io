<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cpp on Declaration of VAR</title>
    <link>https://retifrav.github.io/tags/cpp/</link>
    <description>Recent content in cpp on Declaration of VAR</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>retif</copyright>
    <lastBuildDate>Sat, 22 Jul 2023 14:32:36 +0200</lastBuildDate><atom:link href="https://retifrav.github.io/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CMake target_link_libraries() scopes</title>
      <link>https://retifrav.github.io/blog/2023/07/22/cmake-target-link-libraries-scopes/</link>
      <pubDate>Sat, 22 Jul 2023 14:32:36 +0200</pubDate>
      
      <guid>https://retifrav.github.io/blog/2023/07/22/cmake-target-link-libraries-scopes/</guid>
      <description>&lt;p&gt;The CMake&amp;rsquo;s &lt;a href=&#34;https://cmake.org/cmake/help/latest/command/target_link_libraries.html&#34;&gt;target_link_libraries()&lt;/a&gt; function has different &lt;a href=&#34;https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#target-usage-requirements&#34;&gt;scopes&lt;/a&gt; (&lt;em&gt;&lt;code&gt;PRIVATE&lt;/code&gt;/&lt;code&gt;INTERFACE&lt;/code&gt;/&lt;code&gt;PUBLIC&lt;/code&gt;&lt;/em&gt;), and I never understood what exactly each one of them means and how do they actually affect the final result.&lt;/p&gt;


    &lt;img class=&#34;image-post&#34; loading=&#34;lazy&#34; src=&#34;https://retifrav.github.io/blog/2023/07/22/cmake-target-link-libraries-scopes/images/cmake-linking.png&#34; alt=&#34;CMake, linking 3rd-party dependency, your SDK and application&#34;&gt;

&lt;p&gt;As there is a limit for how long one can postpone one&amp;rsquo;s ignorance, it finally came a time for me to investigate the matter, which I did by (&lt;em&gt;reading the documentation and&lt;/em&gt;) conducting a small experiment of my own.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Building stuff from sources on Steam Deck</title>
      <link>https://retifrav.github.io/blog/2023/05/28/steam-deck-building-stuff-from-sources/</link>
      <pubDate>Sun, 28 May 2023 20:46:09 +0200</pubDate>
      
      <guid>https://retifrav.github.io/blog/2023/05/28/steam-deck-building-stuff-from-sources/</guid>
      <description>&lt;p&gt;My &lt;a href=&#34;https://retifrav.github.io/blog/2023/04/10/steam-deck/&#34;&gt;previous article&lt;/a&gt; about Steam Deck has exploded in size, so I decided to move the part about installing packages and building stuff into a separate article.&lt;/p&gt;


    &lt;img class=&#34;image-post&#34; loading=&#34;lazy&#34; src=&#34;https://retifrav.github.io/blog/2023/05/28/steam-deck-building-stuff-from-sources/images/steam-deck-dock-mouse-keyboard.jpg&#34; alt=&#34;Steam Deck, Konsole in Desktop mode and docked with mouse and keyboard&#34;&gt;

&lt;p&gt;But it&amp;rsquo;s not just already published parts, there are some new things too: in particular, I&amp;rsquo;ve managed to build Qt (&lt;em&gt;both shared and static configurations&lt;/em&gt;) and used it to build my own applications.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Managing dependencies in a C&#43;&#43; project with vcpkg</title>
      <link>https://retifrav.github.io/blog/2022/10/30/cpp-dependencies-with-vcpkg/</link>
      <pubDate>Sun, 30 Oct 2022 16:09:08 +0200</pubDate>
      
      <guid>https://retifrav.github.io/blog/2022/10/30/cpp-dependencies-with-vcpkg/</guid>
      <description>&lt;p&gt;More than half a year ago I was &lt;a href=&#34;https://retifrav.github.io/blog/2022/02/06/cpp-dependencies-with-conan/&#34;&gt;trying out Conan&lt;/a&gt; package manager for resolving dependencies in our C++ project. The research went well, but we never actually proceeded with switching to Conan for the whole project. And then a couple of weeks ago I started looking into &lt;a href=&#34;https://vcpkg.io/&#34;&gt;vcpkg&lt;/a&gt;.&lt;/p&gt;


    &lt;img class=&#34;image-post&#34; loading=&#34;lazy&#34; src=&#34;https://retifrav.github.io/blog/2022/10/30/cpp-dependencies-with-vcpkg/images/vcpkg.png&#34; alt=&#34;vcpkg logo&#34;&gt;

&lt;p&gt;I&amp;rsquo;ve heard about vcpkg before and even tried to make a vcpkg package for one library a couple of years ago, but back then I didn&amp;rsquo;t find documentation for this (&lt;em&gt;as I now understand, that&amp;rsquo;s because one does not really create a &amp;ldquo;package&amp;rdquo;&lt;/em&gt;) and abandonned the task. I never thought I&amp;rsquo;ll be looking at vcpkg again, but recently I discovered that some teams have been switching from Conan to vcpkg, which sounded intriguing and promising, as we still needed a package manager for our projects.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Conan and resolving dependencies in a C&#43;&#43; project</title>
      <link>https://retifrav.github.io/blog/2022/02/06/cpp-dependencies-with-conan/</link>
      <pubDate>Sun, 06 Feb 2022 14:47:47 +0100</pubDate>
      
      <guid>https://retifrav.github.io/blog/2022/02/06/cpp-dependencies-with-conan/</guid>
      <description>&lt;p&gt;Like many other teams, we have a fair amount of 3rd-party dependencies in our project (&lt;em&gt;a C++-based SDK, that is&lt;/em&gt;). Like fewer other teams, we store those dependencies source code right in our project repository and we build them together with the project sources every time. This is of course a tremendous waste of time and CPU cycles, as it would be much more efficient to build dependencies just once (&lt;em&gt;per version&lt;/em&gt;) and link to already pre-built binaries.&lt;/p&gt;



&lt;figure class=&#34;with-original&#34;&gt;
    &lt;img class=&#34;image-post&#34; loading=&#34;lazy&#34; src=&#34;https://retifrav.github.io/blog/2022/02/06/cpp-dependencies-with-conan/images/conan-the-librarian.png&#34; alt=&#34;Conan The Librarian&#34;&gt;
    &lt;footer&gt;
        &lt;small&gt;
            &lt;i&gt;&lt;a href=&#34;https://igorcomics.blogspot.com/2017/11/conan-librarian.html&#34;&gt;original picture&lt;/a&gt;&lt;/i&gt;
        &lt;/small&gt;
    &lt;/footer&gt;
&lt;/figure&gt;

&lt;p&gt;But where to store pre-built dependencies and how to fetch the correct variants for various platforms, toolchains and configurations? Our investigation on the matter led us to &lt;a href=&#34;https://conan.io/&#34;&gt;Conan&lt;/a&gt; package manager.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Making a deb package with CMake/CPack and hosting it in a private APT repository</title>
      <link>https://retifrav.github.io/blog/2021/09/23/cmake-cpack-package-deb-apt/</link>
      <pubDate>Thu, 23 Sep 2021 11:26:15 +0200</pubDate>
      
      <guid>https://retifrav.github.io/blog/2021/09/23/cmake-cpack-package-deb-apt/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://retifrav.github.io/blog/2021/03/08/cmake-cpp-library/&#34;&gt;Last time&lt;/a&gt; I needed to handle a C++ library project with CMake. This time I was tasked with creating a deb package for one of the libraries in our SDK.&lt;/p&gt;


    &lt;img class=&#34;image-post&#34; loading=&#34;lazy&#34; src=&#34;https://retifrav.github.io/blog/2021/09/23/cmake-cpack-package-deb-apt/images/cmake-cpack-deb.png&#34; alt=&#34;CMake, CPack, deb package&#34;&gt;

&lt;p&gt;And what would you know, CMake can handle packaging too - with &lt;a href=&#34;https://cmake.org/cmake/help/latest/module/CPack.html&#34;&gt;CPack&lt;/a&gt; utility.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Creating a C&#43;&#43; library with CMake</title>
      <link>https://retifrav.github.io/blog/2021/03/08/cmake-cpp-library/</link>
      <pubDate>Mon, 08 Mar 2021 20:41:56 +0100</pubDate>
      
      <guid>https://retifrav.github.io/blog/2021/03/08/cmake-cpp-library/</guid>
      <description>&lt;p&gt;All of the sudden I found myself in a situation that I have been successfully avoiding so far - I needed to make a C++ library with CMake.&lt;/p&gt;


    &lt;img class=&#34;image-post&#34; loading=&#34;lazy&#34; src=&#34;https://retifrav.github.io/blog/2021/03/08/cmake-cpp-library/images/cmake-library.png&#34; alt=&#34;CMake and a library&#34;&gt;

&lt;p&gt;To clarify, this will be about so-called &lt;a href=&#34;https://cmake.org/cmake/help/latest/command/add_library.html#normal-libraries&#34;&gt;normal&lt;/a&gt; kind of library.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Logstalgia, build for Windows</title>
      <link>https://retifrav.github.io/blog/2019/08/17/logstalgia-windows-build/</link>
      <pubDate>Sat, 17 Aug 2019 14:20:36 +0200</pubDate>
      
      <guid>https://retifrav.github.io/blog/2019/08/17/logstalgia-windows-build/</guid>
      <description>&lt;p&gt;There is this amazing tool &lt;a href=&#34;https://logstalgia.io&#34;&gt;Logstalgia&lt;/a&gt; which visualizes web-server logs. Sadly, there were no new builds for Windows after the version 1.0.9, so I decided to make one with the latest version (&lt;em&gt;1.1.2 at the moment&lt;/em&gt;).&lt;/p&gt;


    &lt;img class=&#34;image-post&#34; loading=&#34;lazy&#34; src=&#34;https://retifrav.github.io/blog/2019/08/17/logstalgia-windows-build/images/logstalgia-windows-build.png&#34; alt=&#34;Logstalgia, Windows build&#34;&gt;

&lt;p&gt;I will describe the process and also publish pre-built binaries.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>GLFW and Dear ImGui</title>
      <link>https://retifrav.github.io/blog/2019/08/04/glfw-dear-imgui/</link>
      <pubDate>Sun, 04 Aug 2019 14:56:39 +0200</pubDate>
      
      <guid>https://retifrav.github.io/blog/2019/08/04/glfw-dear-imgui/</guid>
      <description>&lt;p&gt;Last time I tried &lt;a href=&#34;https://retifrav.github.io/blog/2019/05/26/sdl-imgui/&#34;&gt;SDL and Dear ImGui&lt;/a&gt; and that was quite interesting. So today I would like to explore a GLFW and Dear ImGui combo.&lt;/p&gt;


    &lt;img class=&#34;image-post&#34; loading=&#34;lazy&#34; src=&#34;https://retifrav.github.io/blog/2019/08/04/glfw-dear-imgui/images/glfw-imgui-macos.png&#34; alt=&#34;GLFW, Dear ImGui on Mac OS&#34;&gt;

&lt;p&gt;There will be also a silly SDL vs GLFW comparison.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SDL and Dear ImGui, C&#43;&#43; GUI without Qt</title>
      <link>https://retifrav.github.io/blog/2019/05/26/sdl-imgui/</link>
      <pubDate>Sun, 26 May 2019 16:08:19 +0200</pubDate>
      
      <guid>https://retifrav.github.io/blog/2019/05/26/sdl-imgui/</guid>
      <description>&lt;p&gt;Qt is certainly great, but there are other ways for creating cross-platform GUI, one of such ways being a combination of &lt;a href=&#34;https://www.libsdl.org&#34;&gt;SDL&lt;/a&gt; and &lt;a href=&#34;https://github.com/ocornut/imgui&#34;&gt;Dear ImGui&lt;/a&gt;.&lt;/p&gt;


    &lt;img class=&#34;image-post&#34; loading=&#34;lazy&#34; src=&#34;https://retifrav.github.io/blog/2019/05/26/sdl-imgui/images/sdl-imgui.png&#34; alt=&#34;SDL and Dear ImGui&#34;&gt;

&lt;p&gt;While, in my opinion, it barely can compete with Qt (especially Qt Quick) in terms of beauty and fancy, it is nevertheless a simple, lightweight and quite powerful &amp;ldquo;framework&amp;rdquo;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Visual Studio Code and CMake for Qt</title>
      <link>https://retifrav.github.io/blog/2019/05/11/vscode-cmake-qt/</link>
      <pubDate>Sat, 11 May 2019 15:00:23 +0200</pubDate>
      
      <guid>https://retifrav.github.io/blog/2019/05/11/vscode-cmake-qt/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://blog.qt.io/blog/2017/05/29/qbs-1-8-released/&#34;&gt;After&lt;/a&gt; &lt;a href=&#34;https://blog.qt.io/blog/2017/09/05/qbs-1-9-released/&#34;&gt;numerous&lt;/a&gt; &lt;a href=&#34;https://blog.qt.io/blog/2017/12/07/qbs-1-10-released/&#34;&gt;promises&lt;/a&gt; of how &lt;a href=&#34;https://doc.qt.io/qbs/index.html&#34;&gt;Qbs&lt;/a&gt; will be the Qt&amp;rsquo;s default build system, The Qt Company suddenly &lt;a href=&#34;https://blog.qt.io/blog/2018/10/29/deprecation-of-qbs/&#34;&gt;killed it&lt;/a&gt;, announced that &lt;a href=&#34;https://doc.qt.io/qt-5/qmake-manual.html&#34;&gt;qmake&lt;/a&gt; is a dead man walking too, and actually Qt is switching to &lt;a href=&#34;https://cmake.org&#34;&gt;CMake&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So I guess we should start using CMake for building Qt applications as well. Let&amp;rsquo;s see then what it takes to switch from qmake to CMake with a couple of basic examples.&lt;/p&gt;


    &lt;img class=&#34;image-post&#34; loading=&#34;lazy&#34; src=&#34;https://retifrav.github.io/blog/2019/05/11/vscode-cmake-qt/images/qt-cmake-vscode.png&#34; alt=&#34;Qt, CMake and Visual Studio Code&#34;&gt;

&lt;p&gt;I also wanted to try Qt development with Visual Studio Code, and now is a good occasion for that.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
